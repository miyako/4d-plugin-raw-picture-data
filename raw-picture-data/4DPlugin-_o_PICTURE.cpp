/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-_o_PICTURE.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : _o_PICTURE
 #	author : miyako
 #	2020/02/20
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-_o_PICTURE.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- _o_PICTURE
            
			case 1 :
				GET_PICTURE_DATA(params);
				break;
			case 2 :
				Get_picture_data_for_type(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void GET_PICTURE_DATA(PA_PluginParameters params) {

    PA_Picture Param1 = PA_GetPictureParameter(params, 1);
    PA_Variable Param2 = PA_GetVariableParameter(params, 2);
    PA_Variable Param3 = PA_GetVariableParameter(params, 3);

    switch (Param2.fType) {
            
        case eVK_ArrayUnicode:
            break;
        case eVK_Undefined:
            PA_ClearVariable(&Param2);
            Param2 = PA_CreateVariable(eVK_ArrayUnicode);
            break;
        default:
            break;
    }
    
    switch (Param3.fType) {
            
        case eVK_ArrayPicture:
            break;
        case eVK_Undefined:
            PA_ClearVariable(&Param3);
            Param3 = PA_CreateVariable(eVK_ArrayBlob);
            break;
        default:
            break;
    }
    
    if((Param2.fType == eVK_ArrayUnicode) && (Param3.fType == eVK_ArrayBlob)) {
        
        PA_ResizeArray(&Param2, 0);
        PA_ResizeArray(&Param3, 0);
        
        unsigned int i = 0;
        
        PA_ErrorCode err = eER_NoErr;
        PA_Unistring type;
        
        while (err == eER_NoErr) {
            
            i++;
            type = PA_GetPictureData(Param1, i, 0);
            err = PA_GetLastError();
            if(err == eER_NoErr) {
                PA_Handle h = PA_NewHandle(0);
                PA_GetPictureData(Param1, i, h);
                err = PA_GetLastError();
                if(err == eER_NoErr) {
                                        
                    PA_ResizeArray(&Param2, i);
                    PA_ResizeArray(&Param3, i);
    
                    PA_Variable element = PA_CreateVariable(eVK_Blob);
                    PA_SetBlobVariable(&element, (void *)PA_LockHandle(h), PA_GetHandleSize(h));
                    PA_SetBlobInArray(Param3, i, element.uValue.fBlob);
                    PA_UnlockHandle(h);
                    
                    PA_SetStringInArray(Param2, i, &type);
                }
                PA_DisposeHandle(h);
            }
        }
                
        PackagePtr pParams = (PackagePtr)params->fParameters;
        
        PA_Variable *param2 = ((PA_Variable *)pParams[1]);
        PA_Variable *param3 = ((PA_Variable *)pParams[2]);
        
        param2->fType = Param2.fType;
        param2->fFiller = Param2.fFiller;
        param2->uValue.fArray.fCurrent = Param2.uValue.fArray.fCurrent;
        param2->uValue.fArray.fNbElements = Param2.uValue.fArray.fNbElements;
        param2->uValue.fArray.fData = Param2.uValue.fArray.fData;
                
        param3->fType = Param3.fType;
        param3->fFiller = Param3.fFiller;
        param3->uValue.fArray.fCurrent = Param3.uValue.fArray.fCurrent;
        param3->uValue.fArray.fNbElements = Param3.uValue.fArray.fNbElements;
        param3->uValue.fArray.fData = Param3.uValue.fArray.fData;
    }

}

void Get_picture_data_for_type(PA_PluginParameters params) {
         
    PA_Picture Param1 = PA_GetPictureParameter(params, 1);
    
    PA_Unistring *str = PA_GetStringParameter(params, 2);
    CUTF16String typeToGet = CUTF16String(str->fString, str->fLength);
    
    unsigned int i = 0;
    
    PA_ErrorCode err = eER_NoErr;
    std::map<CUTF16String, uint32_t>allTypes;
    
    while (err == eER_NoErr) {
        
        i++;
        PA_Unistring type = PA_GetPictureData(Param1, i, NULL);
        err = PA_GetLastError();
        if(err == eER_NoErr) {
            
            CUTF16String typesString = CUTF16String(type.fString, type.fLength);
            CUTF16String typeName;
            
            size_t pos, found;
            found = 0;
            
            for(pos = typesString.find(';'); pos != CUTF16String::npos; pos = typesString.find(';', found)) {
                
                typeName = typesString.substr(found, pos-found);
                found = pos + 1;
                allTypes.insert(std::map<CUTF16String, uint32_t>::value_type(typeName, i));
            }
            
            typeName = typesString.substr(found, typesString.length()-found);
            allTypes.insert(std::map<CUTF16String, uint32_t>::value_type(typeName, i));
        }
    }

    std::map<CUTF16String, uint32_t>::iterator itr;
    
    itr = allTypes.find(typeToGet.c_str());
    
    err = eER_IncompatibleTypes;
        
    if (itr != allTypes.end()) {
        
        uint32_t pos = itr->second;
        
        PA_Handle h = PA_NewHandle(0);
        
        err = eER_NoErr;
        PA_GetPictureData(Param1, pos, h);
        err = PA_GetLastError();
        
        if(err == eER_NoErr) {
            
            PA_ReturnBlob(params, (void *)PA_LockHandle(h), PA_GetHandleSize(h));
            PA_UnlockHandle(h);
        }
        
        PA_DisposeHandle(h);
    }

}

void Create_picture_from_PICT_data(PA_PluginParameters params) {

#if VERSIONMAC
    std::vector<uint8_t>buf;
    
    PA_Handle h = PA_GetBlobHandleParameter(params, 1);
    
    if(h) {
        unsigned int size = PA_GetHandleSize(h);
        if(size) {
            buf.resize(size);
            PA_MoveBlock(PA_LockHandle(h), (char *)&buf[0], size);
            PA_UnlockHandle(h);
            
            NSData *data = [[NSData alloc]initWithBytes:&buf[0] length:size];
            
            NSPICTImageRep *imageRep = [[NSPICTImageRep alloc]initWithData:data];
            
            //doesn't work; image is empty
            
            NSImage *nsimage = [[NSImage alloc]init];
            [nsimage addRepresentation:imageRep];
            [nsimage release];
            
            //doesn't work; image is empty
            
            NSRect boundingBox = [imageRep boundingBox];
            CGImageRef cgimage = [imageRep CGImageForProposedRect:&boundingBox context:NULL hints:NULL];
            
            if(cgimage) {
                
                CFMutableDataRef mudata = CFDataCreateMutable(kCFAllocatorDefault, 0);
                CGImageDestinationRef destination = CGImageDestinationCreateWithData(mudata, kUTTypeTIFF, 1, NULL);
                CFMutableDictionaryRef properties = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
                CGImageDestinationAddImage(destination, cgimage, properties);
                CGImageDestinationFinalize(destination);

                PA_Picture picture = PA_CreatePicture((void *)CFDataGetBytePtr(mudata), (PA_long32)CFDataGetLength(mudata));
                PA_ReturnPicture(params, picture);
                
                CFRelease(properties);
                CFRelease(destination);
                CFRelease(mudata);
                
                CFRelease(cgimage);
            }

            [imageRep release];
            [data release];
        }
    }
#endif
}

